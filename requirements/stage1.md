## Описание этапа
Ваша задача состоит в написании скелета бота, добавлении сетевых
вызовов согласно OpenAPI-контракту, реализации HTTP-клиентов (для внешних и внутренних вызовов) и планировщика задач (проверятель ссылок).

## Функциональные требования
Бот должен поддерживать следующие команды:
* /start - регистрация пользователя.
* /help - вывод списка доступных команд.
* /track - начать отслеживание ссылки.
* /untrack - прекратить отслеживание ссылки.
* /list - показать список отслеживаемых ссылок (cписок ссылок, полученных при /track)
    * Команда /list должна выводить специальное сообщение, если список отслеживаемых ссылок пуст.

Неизвестные команды должны игнорироваться с уведомлением

При попытке добавить ссылку, которая уже отслеживается, выводится сообщение: 
* "Ссылка уже отслеживается"

Все endpoint'ы соответствуют OpenAPI-контрактуРазрешено модифицировать LinkUpdate в Bot API для расширения
и добавления новой информации (для упрощения
форматирования)
Ссылка на контракт OpenAPI: https://gist.github.com/sanyarnd/e35dc3d4e0c8000205ec5029dac38f5a (2 файла)

Реализован базовый планировщик: бот присылает простейшее
уведомление (заглушку) в случае обнаружения изменений
* Для golang использовать gocron
* Достаточно факта уведомления, пока нет требования писать с
детализацией, например "обновление в комментарии от
пользователя Х по ссылке Y"
* На следующем этапе планировщик должен учитывать факт, что
пользователь не один, а пока вы можете реализовать самую
простую версию


## Нефункциональные требования
Токен авторизации должен храниться в конфигурационном файле,
недоступном для общего доступа

Поддерживается скреппинг вопросов StackOverflow и репозиториев GitHub -- вам нужно написать HTTP-клиентов для получения необходимой информации из API

* Для текущей версии задания достаточно факта, что появились
обновления, без детализации, что именно было обновлено, т.е.
достаточно использовать факт изменения поля, отвечающего за
дату последнего изменения (lastUpdated и т.п.)

* Не нужно парсить страницу (HTML), нужно работать с API: GitHub, StackOverflow

Запрещается использовать готовые SDK для доступа к API для HTTP-клиентов (GitHub, StackOverflow): 
* Клиентов нужно написать руками
* По возможности используйте декларативные клиенты

Бот должен реализовывать концепт машины состояний (создание /
track должно идти в формате диалога, а не команды):
неверно: /track tag=work tag=hobby https://foo.bar/baz
верно: 

\> /track https://foo.bar/baz (можно раздельно /track и отдельно
ссылка)

\< введите тэги (опционально)

\> work hobby

\< настройте фильтры (опционально)

\> user:dummy type:comment

В тестах запрещено делать реальные вызовы к API внешних систем, нужно использовать заглушки (mocks). Используйте типобезопасную конфигурацию Пример для Java, Python, Go, Scala
Используйте структурное логирование (добавление key-value
значений к логу, вместо зашивания данных в поле message) в коде приложения

## Обязательные тесты

* Корректный парсинг ссылок

* Правильное сохранение данных в репозиторий из запроса пользователя: ссылка, тэги, фильтры

* Тесты на happy path: добавление и удаление ссылок из репозитория
* Тест на добавление дубля ссылки
* Тесты для планировщика: обновление отправляется только
пользователям, которые следят за ссылкой
* Тесты на корректную обработку ошибок HTTP-запросов
(некорректное тело, код) в клиентах
Проверка форматирования команды /list

# TODO — Реализация бота для трекинга ссылок

## 1. Базовая архитектура
- [ ] Определить структуру проекта (бот, к
- [ ] лиенты API, планировщик, конфиг, тесты).
- [ ] Добавить поддержку конфигурации (токен авторизации, параметры API).
- [ ] Хранить токен в отдельном конфигурационном файле, недоступном для общего доступа.
- [ ] Реализовать типобезопасную конфигурацию.

## 2. Логика бота (машина состояний)
- [ ] Реализовать команды:
  - [ ] `/start` — регистрация пользователя.
  - [ ] `/help` — вывод списка доступных команд.
  - [ ] `/track` — начало диалога по отслеживанию ссылки.
    - [ ] Запросить ссылку.
    - [ ] Запросить тэги (опционально).
    - [ ] Запросить фильтры (опционально).
    - [ ] Сохранить в репозиторий.
  - [ ] `/untrack` — прекращение отслеживания ссылки.
  - [ ] `/list` — вывод списка отслеживаемых ссылок.
    - [ ] Вывести специальное сообщение, если список пуст.
- [ ] Обрабатывать неизвестные команды с уведомлением.
- [ ] Выводить сообщение `"Ссылка уже отслеживается"` при попытке добавить дубликат.

## 3. Репозиторий данных
- [ ] Хранить список отслеживаемых ссылок с тэгами и фильтрами.
- [ ] Поддержка добавления/удаления ссылок.
- [ ] Проверка на дубликаты.
- [ ] Сохранение в устойчивое хранилище (пока можно in-memory, позже — БД).

## 4. HTTP-клиенты
- [ ] Реализовать клиента GitHub API:
  - [ ] Получение информации по репозиторию.
  - [ ] Использование поля `lastUpdated` или аналогичного для определения изменений.
- [ ] Реализовать клиента StackOverflow API:
  - [ ] Получение информации по вопросу.
  - [ ] Использование поля `lastUpdated` или аналогичного.
- [ ] Не использовать готовые SDK, только собственные HTTP-клиенты.
- [ ] Сделать клиентов декларативными.
- [ ] Обрабатывать ошибки HTTP-запросов (код, некорректное тело).
- [ ] В тестах использовать заглушки (mocks), а не реальные вызовы.

## 5. Планировщик (gocron)
- [ ] Реализовать базовый планировщик.
- [ ] Проверять отслеживаемые ссылки на обновления.
- [ ] При изменении отправлять пользователю уведомление (пока заглушка).
- [ ] На текущем этапе — один пользователь, без многопользовательской логики.

## 6. Логирование
- [ ] Использовать структурное логирование (key-value формат).
- [ ] Логировать ключевые события: добавление ссылки, удаление, ошибка клиента, запуск планировщика.

## 7. Тесты
- [ ] Тест на корректный парсинг ссылок.
- [ ] Тест на правильное сохранение данных в репозиторий (ссылка, тэги, фильтры).
- [ ] Happy path тесты:
  - [ ] Добавление ссылки.
  - [ ] Удаление ссылки.
- [ ] Тест на добавление дубля ссылки.
- [ ] Тесты для планировщика:
  - [ ] Уведомление отправляется только пользователям, которые следят за ссылкой.
- [ ] Тесты на корректную обработку ошибок HTTP-клиентов.
- [ ] Тест форматирования команды `/list`.

## 8. Форматирование и стиль
- [ ] Соблюдать требования OpenAPI-контракта.
- [ ] При необходимости модифицировать `LinkUpdate` в Bot API для удобного форматирования.
